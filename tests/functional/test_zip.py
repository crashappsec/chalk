# Copyright (c) 2023, Crash Override, Inc.
#
# This file is part of Chalk
# (see https://crashoverride.com/docs/chalk)
from pathlib import Path
import zipfile

import pytest

from .chalk.runner import Chalk
from .conf import CONFIGS, ZIPS
from .utils.dict import Contains, IfExists
from .utils.log import get_logger


logger = get_logger()

# Test data fixtures
EMPTY_ZIP = ZIPS / "empty" / "empty.zip"
GOLANG_LAMBDA_ZIP = ZIPS / "golang" / "myFunction.zip"
MISC_LAMBDA_ZIP = ZIPS / "misc" / "misc.serverless.zip"
NODEJS_LAMBDA_ZIP = ZIPS / "nodejs" / "function.zip"
PYTHON_LAMBDA_ZIP = ZIPS / "python" / "my_deployment_package.zip"
JAR_FILE = ZIPS / "misc" / "test.jar"
DOUBLE_EXT_ZIP = ZIPS / "misc" / "test.serverless.zip"
TERRAFORM_ZIP = ZIPS / "terraform" / "test.zip"

# Test configs
SERVERLESS_CONFIG = CONFIGS / "serverless_zip.c4m"


@pytest.mark.slow()
@pytest.mark.parametrize(
    "copy_files",
    [
        [NODEJS_LAMBDA_ZIP],
        [PYTHON_LAMBDA_ZIP],
        [TERRAFORM_ZIP],
    ],
    indirect=True,
)
@pytest.mark.parametrize("virtual", [True, False])
@pytest.mark.parametrize("inject_binary_into_zip", [True, False])
def test_valid_slow(
    tmp_data_dir: Path,
    chalk: Chalk,
    copy_files: list[Path],
    virtual: bool,
    inject_binary_into_zip: bool,
):
    test_file = copy_files[0]

    # chalk reports generated by insertion, json array that has one element
    insert = chalk.insert(
        artifact=tmp_data_dir,
        virtual=virtual,
        inject_binary_into_zip=inject_binary_into_zip,
        config=CONFIGS / "zip.c4m",
    )
    assert insert.report.marks_by_path.contains(
        {
            str(test_file): {
                "EMBEDDED_CHALK": IfExists(
                    Contains(
                        [
                            {
                                "CONTAINING_ARTIFACT_WHEN_CHALKED": insert.mark[
                                    "CHALK_ID"
                                ],
                                "PATH_WITHIN_ZIP": str,
                            }
                        ],
                    ),
                ),
            },
        },
    )

    # chalk binary is not injected if --virtual flag is present
    if inject_binary_into_zip and should_inject_binary(test_file, virtual):
        assert contains_chalk_binary(test_file)
    # array of json chalk objects as output, of which we are only expecting one
    extract = chalk.extract(artifact=tmp_data_dir, virtual=virtual)
    if not virtual:
        assert extract.mark.contains(insert.mark.if_exists())
        assert extract.report.marks_by_path.contains({str(test_file): {}})

    insert2 = chalk.insert(
        artifact=tmp_data_dir,
        virtual=virtual,
        inject_binary_into_zip=inject_binary_into_zip,
        config=CONFIGS / "zip.c4m",
    )
    assert insert.mark.contains(
        insert2.mark.exclude(
            "EMBEDDED_CHALK",
            "EMBEDDED_TMPDIR",
            "METADATA_HASH",
            "METADATA_ID",
            "HASH",
            "_CURRENT_HASH",
            "CHALK_RAND",
        )
    )


@pytest.mark.parametrize(
    "copy_files",
    [
        # empty zip file does not get chalked, so no artifact info
        [EMPTY_ZIP],
    ],
    indirect=True,
)
@pytest.mark.parametrize("virtual", [True, False])
@pytest.mark.parametrize("inject_binary_into_zip", [True, False])
def test_empty(
    tmp_data_dir: Path,
    copy_files: list[Path],
    chalk: Chalk,
    virtual: bool,
    inject_binary_into_zip: bool,
):
    # no _CHALK will be generated on an unchalked empty zip
    assert chalk.insert(
        artifact=tmp_data_dir,
        virtual=virtual,
        inject_binary_into_zip=inject_binary_into_zip,
        expecting_chalkmarks=False,
    )
    assert chalk.extract(
        artifact=tmp_data_dir,
        virtual=virtual,
        expecting_chalkmarks=False,
    )


@pytest.mark.parametrize(
    "copy_files",
    [
        [MISC_LAMBDA_ZIP],
        [GOLANG_LAMBDA_ZIP],
    ],
    indirect=True,
)
@pytest.mark.parametrize("virtual", [True, False])
@pytest.mark.parametrize("inject_binary_into_zip", [True, False])
def test_valid(
    tmp_data_dir: Path,
    chalk: Chalk,
    copy_files: list[Path],
    virtual: bool,
    inject_binary_into_zip: bool,
):
    test_file = copy_files[0]

    # chalk reports generated by insertion, json array that has one element
    insert = chalk.insert(
        artifact=tmp_data_dir,
        virtual=virtual,
        inject_binary_into_zip=inject_binary_into_zip,
    )
    # we are only checking the ZIP chalk mark, not any of the subchalks
    assert insert.report.marks_by_path.contains({str(test_file): {}})

    # array of json chalk objects as output, of which we are only expecting one
    extract = chalk.extract(artifact=tmp_data_dir, virtual=virtual)
    if not virtual:
        assert extract.report.marks_by_path.contains({str(test_file): {}})
        assert extract.mark.contains(insert.mark.if_exists())
    if inject_binary_into_zip and should_inject_binary(test_file, virtual):
        assert contains_chalk_binary(test_file)


@pytest.mark.slow()
@pytest.mark.parametrize(
    "copy_files",
    [
        [JAR_FILE],
    ],
    indirect=True,
)
def test_jar_files_never_injected(
    tmp_data_dir: Path,
    chalk: Chalk,
    copy_files: list[Path],
):
    """Test that .jar files never have chalk binary injected."""
    test_file = copy_files[0]

    # Test with serverless config that has allowed extensions
    insert = chalk.insert(
        config=SERVERLESS_CONFIG,
        artifact=test_file,
        inject_binary_into_zip=True,
    )
    assert insert.report.marks_by_path.contains({str(test_file): {}})

    # .jar files should never have binary injected
    expected_injection = should_inject_binary(test_file, False)
    verify_binary_injection(test_file, False, expected_injection)

    # Explicitly verify .jar files never get injection
    assert (
        not expected_injection
    ), f"JAR files should never have binary injection enabled"


def contains_chalk_binary(zip_path: Path):
    """Helper function to verify chalk binary in the zip file."""
    with zipfile.ZipFile(zip_path, "r") as zip_ref:
        # Verify the chalk binary was added
        return "chalk" in zip_ref.namelist()


def should_inject_binary(file_path: Path, virtual: bool) -> bool:
    """Determine if binary should be injected based on file extension and config."""
    if virtual:
        return False

    # Based on serverless_zip.c4m config: zip.allowed_extensions: ["zip", "serverless.zip"]
    # .jar files should never have binary injected
    if file_path.suffix == ".jar":
        return False

    # Files with multiple extensions like "test.serverless.zip" should be handled
    # by checking if the full extension matches allowed patterns
    full_name = file_path.name
    if full_name.endswith(".serverless.zip"):
        return True
    elif file_path.suffix == ".zip":
        return True

    return False


def verify_binary_injection(file_path: Path, virtual: bool, expected_injection: bool):
    """Verify binary injection matches expectation with clear assertion message."""
    actual_injection = contains_chalk_binary(file_path)
    if expected_injection:
        assert (
            actual_injection
        ), f"Expected chalk binary to be injected in {file_path.name} (virtual={virtual})"
    else:
        assert (
            not actual_injection
        ), f"Expected chalk binary NOT to be injected in {file_path.name} (virtual={virtual})"
