# Copyright (c) 2023, Crash Override, Inc.
#
# This file is part of Chalk
# (see https://crashoverride.com/docs/chalk)
import re
import shutil
from pathlib import Path
from typing import IO
from unittest import mock

import os
import pytest

from .chalk.runner import Chalk
from .chalk.validate import (
    ArtifactInfo,
    validate_chalk_report,
    validate_extracted_chalk,
    validate_virtual_chalk,
)
from .conf import CODEOWNERS, CONFIGS, LS_PATH
from .utils.git import init
from .utils.log import get_logger


logger = get_logger()


def test_codeowners(tmp_data_dir: Path, chalk: Chalk):
    folder = CODEOWNERS / "raw1"
    expected_owners = (folder / "CODEOWNERS").read_text()
    shutil.copytree(folder, tmp_data_dir, dirs_exist_ok=True)
    artifact_info = ArtifactInfo.all_shebangs()
    assert len(artifact_info) == 1
    artifact = Path(list(artifact_info.keys())[0])
    init(tmp_data_dir)

    # chalk reports generated by insertion, json array that has one element
    insert = chalk.insert(artifact=artifact, virtual=True)
    assert insert.mark["CODE_OWNERS"] == expected_owners
    # check chalk report
    validate_chalk_report(
        chalk_report=insert.report, artifact_map=artifact_info, virtual=True
    )

    # array of json chalk objects as output, of which we are only expecting one
    extract = chalk.extract(artifact=tmp_data_dir)
    validate_extracted_chalk(
        extracted_chalk=extract.report, artifact_map=artifact_info, virtual=True
    )
    validate_virtual_chalk(
        tmp_data_dir=tmp_data_dir, artifact_map=artifact_info, virtual=True
    )


# https://docs.github.com/en/actions/learn-github-actions/variables#default-environment-variables
@mock.patch.dict(
    os.environ,
    {
        "CI": "true",
        "GITHUB_SHA": "ffac537e6cbbf934b08745a378932722df287a53",
        "GITHUB_SERVER_URL": "https://github.com",
        "GITHUB_REPOSITORY": "octocat/Hello-World",
        "GITHUB_RUN_ID": "1658821493",
        "GITHUB_API_URL": "https://api.github.com",
        "GITHUB_ACTOR": "octocat",
        # there are a bunch of variations of these
        # but for now at least we test basic flow
        "GITHUB_EVENT_NAME": "push",
        "GITHUB_REF_TYPE": "tag",
    },
)
@pytest.mark.parametrize("copy_files", [[LS_PATH]], indirect=True)
def test_github(copy_files: list[Path], chalk: Chalk):
    bin_path = copy_files[0]
    artifact = ArtifactInfo.one_elf(
        bin_path,
        host_info={
            "BUILD_ID": "1658821493",
            "BUILD_TRIGGER": "tag",
            "BUILD_CONTACT": ["octocat"],
            "BUILD_URI": "https://github.com/octocat/Hello-World/actions/runs/1658821493",
            "BUILD_API_URI": "https://api.github.com",
        },
    )
    insert = chalk.insert(bin_path)

    validate_chalk_report(
        chalk_report=insert.report,
        artifact_map=artifact,
        virtual=False,
        chalk_action="insert",
    )


# https://docs.gitlab.com/ee/ci/variables/predefined_variables.html
@mock.patch.dict(
    os.environ,
    {
        "CI": "true",
        "GITLAB_CI": "true",
        "CI_JOB_URL": "https://gitlab.com/gitlab-org/gitlab/-/jobs/4999820578",
        "CI_JOB_ID": "4999820578",
        "CI_API_V4_URL": "https://gitlab.com/api/v4",
        "GITLAB_USER_LOGIN": "user",
        "CI_PIPELINE_SOURCE": "push",
    },
)
@pytest.mark.parametrize("copy_files", [[LS_PATH]], indirect=True)
def test_gitlab(copy_files: list[Path], chalk: Chalk):
    bin_path = copy_files[0]
    artifact = ArtifactInfo.one_elf(
        bin_path,
        host_info={
            "BUILD_ID": "4999820578",
            "BUILD_TRIGGER": "push",
            "BUILD_CONTACT": ["user"],
            "BUILD_URI": "https://gitlab.com/gitlab-org/gitlab/-/jobs/4999820578",
            "BUILD_API_URI": "https://gitlab.com/api/v4",
        },
    )
    insert = chalk.insert(bin_path)
    validate_chalk_report(
        chalk_report=insert.report,
        artifact_map=artifact,
        virtual=False,
        chalk_action="insert",
    )


@pytest.mark.parametrize("copy_files", [[LS_PATH]], indirect=True)
@pytest.mark.parametrize("tmp_file", [{"path": "/tmp/vendor"}], indirect=True)
def test_imds(
    copy_files: list[Path],
    chalk: Chalk,
    tmp_file: IO,
    server_imds: str,
):
    # make imds plugin think we are running in EC2
    with tmp_file as fid:
        fid.write(b"amazon")
    bin_path = copy_files[0]
    insert = chalk.insert(bin_path, config=CONFIGS / "imds.c4m")
    assert insert.report.contains(
        {
            "_AWS_AMI_ID": "ami-0abcdef1234567890",
            "_AWS_AMI_LAUNCH_INDEX": "0",
            "_AWS_AMI_MANIFEST_PATH": "(unknown)",
            "_AWS_AZ": "us-east-1e",
            "_AWS_AZ_ID": "use1-az3",
            "_AWS_HOSTNAME": "ip-10-251-50-12.ec2.internal",
            "_AWS_IAM_INFO": {
                "Code": "Success",
                "LastUpdated": "2023-09-12T15:16:58Z",
                "InstanceProfileArn": "arn:aws:iam::123456789012:instance-profile/IMDSTestEc2Role",
                "InstanceProfileId": "AIPATILQWXT62BCWDUQCT",
            },
            "_AWS_INSTANCE_ID": "i-abc123xyz789",
            "_AWS_MAC": "00:25:96:FF:FE:12:34:56",
            "_AWS_VPC_ID": "vpc-1234567890",
            "_AWS_SUBNET_ID": "subnet-1234567890",
            "_AWS_INTERFACE_ID": "eni-1234567890",
            "_AWS_SECURITY_GROUPS": {"default", "test"},
            "_AWS_SECURITY_GROUP_IDS": {"sg-1234567890", "sg-098764321"},
            "_AWS_INSTANCE_IDENTITY_DOCUMENT": {
                "accountId": "123456789012",
                "architecture": "x86_64",
                "availabilityZone": "us-east-1e",
                "billingProducts": None,
                "devpayProductCodes": None,
                "marketplaceProductCodes": None,
                "imageId": "ami-0abcdef1234567890",
                "instanceId": "i-abc123xyz789",
                "instanceType": "t2.medium",
                "kernelId": None,
                "pendingTime": "2023-09-11T06:01:38Z",
                "privateIp": "10.251.50.12",
                "ramdiskId": None,
                "region": "us-east-1",
                "version": "2017-09-30",
            },
            "_AWS_INSTANCE_IDENTITY_PKCS7": re.compile(r"^.*=+$"),
            "_AWS_INSTANCE_IDENTITY_SIGNATURE": re.compile(r"^.*=+$"),
            "_AWS_INSTANCE_LIFE_CYCLE": "on-demand",
            "_AWS_INSTANCE_TYPE": "t2.medium",
            "_AWS_LOCAL_HOSTNAME": "ip-10-251-50-12.ec2.internal",
            "_AWS_LOCAL_IPV4_ADDR": "10.251.50.12",
            "_AWS_OPENSSH_PUBKEY": re.compile(r"^ssh-rsa .* test$"),
            "_AWS_PARTITION_NAME": "aws",
            "_AWS_PUBLIC_HOSTNAME": "ec2-203-0-113-25.compute-1.amazonaws.com",
            "_AWS_PUBLIC_IPV4_ADDR": "203.0.113.25",
            "_AWS_REGION": "us-east-1",
            "_AWS_RESOURCE_DOMAIN": "amazonaws.com",
            "_AWS_TAGS": {
                "Name": "foobar",
                "Environment": "staging",
            },
            "_AWS_IDENTITY_CREDENTIALS_EC2_INFO": {
                "Code": "Success",
                "LastUpdated": "2023-09-13T13:13:39Z",
                "AccountId": "123456789012",
            },
            "_AWS_IDENTITY_CREDENTIALS_EC2_SECURITY_CREDENTIALS_EC2_INSTANCE": {
                "Code": "Success",
                "LastUpdated": "2023-09-13T13:12:26Z",
                "Type": "AWS-HMAC",
                "AccessKeyId": "ASIATILQWXT67VGGR4O2",
                "SecretAccessKey": "<<redacted>>",
                "Token": "<<redacted>>",
                "Expiration": "2023-09-13T19:40:12Z",
            },
        }
    )
